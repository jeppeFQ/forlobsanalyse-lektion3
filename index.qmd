---
title: "Event History Analysis: ikke-parametriske metoder (***K***aplan ***M***eier overlevelsestabeller)"
encoding: "UTF-8"
execute:
  echo: false
format:
  revealjs:
    embed-resources: true
    self-contained-math: true
    smaller: true
    scrollable: true
    theme: dark 
    html-math-method:
      method: mathjax
      url: "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML"
    footer: "Jeppe F. Qvist | 27. februar 2025"
---

```{r}
options(scipen=999)

library(tidyverse)
library(gt)
library(survival)
library(ggsurvfit)
library(survminer)
library(latex2exp)
```

## Dagen program

-   Kaplan-Meier estimation.

    -   *Univariat* og *forskel mellem grupper*.

-   Analyse og visualisering i `R`.

-   Introduktion til `registerdata`-sættet og hvordan i går til det resten af kurset.

-   Øvelser.


## Forventet udbytte

::: {.columns} 

::: {.column width="60%"}
### *Viden*

-   Introduktion til `R`-pakker relevant for ***forløbsanalyseanalyse***.
-   Introduktion til test for forskelle mellem grupper

### *Færdigheder*

-   Forbered data til overlevelsesanalyse.
-   **Datamanagement** i `R`.
-   **Kaplan-Meier** overlevelsesanalyse i `R`.
-   **Visualisering** af overlevelsesdata.
    
:::

::: {.column width="40%"}
### *Kompetancer*

-   `Kaplan-Meier` overlevelsesanalyse i R (`univariat` og `bivariat`, inkl. `test af forskelle`).

:::

:::

# Opsummering af grundbegreber og koncepter

## Beskrivende statistik 

#### `Overlevelse` som funktion af tiden udtrykkes som 

$$ S(t) = Pr(T > t)$$

#### `Hazard-raten` udtrykkes som 

$$ h(t) $$ 

og 

$$ h(t) \Rightarrow  0 \:  \text{to} \: \infty $$
da det er en rate og ikke en sandsynlighed. 

<br/>

#### `Median leveltid` udtrykkes som 

$$ S(t) = 0,5 $$

## Overlevelse er et udtryk for ... 

sandsynligheden for at **tiden** fra starten af forløbet indtil hændelsen er større end $t$. 

$$ P \left (  \left \{ T > t \right \} \right ) $$

Denne sandsynlighed kommer til udtryk som (integralet af) en sandsynlighedsfunktion.

$$
S(t) = P(\{T>t\}) = \int_{t}^{\infty} f(t)dt 
$$

## Hazard-raten er et udtryk for ... 

sandsynligheden for at en begivenhed finder sted i et defineret tidsinterval, **betinget** af overlevelse op til det tidspunkt. Hazard-raten udtrykker dermed "styrken" af en begivenheds sandsynlighed, udtrykt som:

$$ h(t) = \frac{f(t)}{\hat{S}(t)} $$

Hvor $f(t)$ er sandsynlighedsfunktion. 

## Median leveltid er et udtryk for ... 

den tidligste tid hvor halvdelen af populationen/sample oplever begivenheden. Vi er altså interesseret i tiden $t$ (den afhængige variabel i overlevelsesanalysen) når: 

$$ \hat{S}(t) = 0,5$$

<br/>

::: aside
Median er foretrukket mål for centralitet over gennemsnittet fordi gennemsnittet vil være nedad-biased hvis dataen er højre-censureret. Særligt hvis et relativt højt antal er censurerede. 
:::



## Median leveltid er et udtryk for ... 

::: columns
<!--  ------------------------------------------->
::: {.column width="50%"}
### Kode

```{r}
#| echo: true

df <- read_csv("flytte.csv")

fit <- survfit(Surv(dur, status) ~ 1, data = df)

median_over_tid <- 82

```
:::

::: {.column width="50%"}
### Output

```{r fig.height=10}
#| echo: false

median_plot <- 
  ggsurvplot(fit, data = df, 
           title = "Overlevelseskurve ('flytte.csv' data fra Moodle)",
           palette = "#da1f66",
           xlab = TeX("Tid ($t$)"),
           ylab = TeX("$\\hat{S}(t)$"),
           linetype = "solid",
           surv.median.line = "hv",
           pval = FALSE,
           risk.table = FALSE)

median_plot[["plot"]] +
  annotate("text", x = 0, y = 0.2, 
           label = paste(" Median\n overlevelsestid:\n", round(median_over_tid, 2), "uger"), 
           color = "#003fa3", hjust = 0, vjust = -0.5) +
  guides(color = FALSE,
         fill = FALSE) + 
  theme_minimal()
  
```
:::
<!--  ------------------------------------------->
:::

## Det vi skal huske er: 

::: {.incremental}

1. $S(t)$ er et mål for overlevelse som en funktion af tiden. Med andre ord, hvor længe man bliver i en pågældende position, bestemt som overlevelsessandsynligheden i alle de foregående tider ganget sammen. ***Fortæller noget om den samlede udvikling***.

2. $h(t)$ fortæller noget om forekomsten af hændelser --- forudsat personen har "overlevet" frem til tidsintervallet --- samt hvordan det udvikler sig over tid. ***Fortæller noget om udviklingen i de enkelte tidsintervaller***.

3. $S(t) = 0,5$ fortæller noget om, hvornår halvdelen af sample/population ikke længere er under risiko for at opleve hændelsen. ***Fortæller noget om et enkelt punkt på kurven***.


:::

# Kaplan-Meier estimation 

## Kaplan-Meier (1)

Med eksemplet fra øvelsen: 

`KM` er en **non-parametric** metode til at estimere risikoen (sandsynligheden) for et udfald efter et givent tidspunkt baseret på de observerede "overlevelses"-tider (`dur`) i population (`df`) --- i.e., der er ingen *a priori* antagelser om den underliggende fordeling af overlevelsestider):

$$
\hat{S}(t) = \prod_{i: t_i < t} \left(1 - \frac{d_j}{n_j}\right)
$$

hvor, $\hat{S}(t)$, **overlevelsesfuntionen**, er den estimerede sandsynlighed for overlevelse ved tid $t$. $t_{j}$ er observede tidspunkter for begivenheden (eng.: *failure times*). $d_{j}$ er antallet af begivenheder ved tid $t_{j}$. $n_{j}$ er antallet af individer der ikke har oplevet begivenhed eller er blevet censureret før tid $t_{j}$.

Med andre ord, vi multiplicere overlevelsessandsynlighederne over alle diskrete tidsintervaller (her, *uger*) hvor flyt finder sted. For hvert diskrete tidspunkt, $t_{j}$, estimeres overlevelsessandsynligheden som produktet af overlevelsessandsynlighederne op til det tidspunkt, justeret for antallet af observerede events, $d_{j}$, og antallet af personer i risiko for flyt, $n_{j}$, op til det tidspunkt.

Det primære "bidrag" med denne metode er at al information frem til censurering anvendes, fremfor at droppe de individer/observationer, der er censureret på et senere tidspunkt; det står delvist i kontrast til typiske tilgange i klassisk regressionsanalyse.   

<br/>


## Kaplan-Meier (2)

Altså,

$d_{j}$ er antallet af hændelser i det diskrete tidsinterval. 

$n_{j}$ er antallet af person i `risikosættet`. Dvs. antallet af personer, der ikke har oplevet **hændelsen** *eller* blevet **censureret** op til tid $j$. Det vil sige at $S_{t}$ er udledt af `risikosættet`: ofte refereret til som $R(t)$. 

$1 - \frac{d_j}{n_j}$ er sandsynlighed for overlevelse, *betinget* af overlevelse frem til $j$.

Med $\prod_{i: t_i < t}$ ganger vi overlevelsessandsynligheder frem til det pågældende tidspunkt, $j$. 

For eksempel: 

|Tid|`Risikosæt` $n_{i}$|`Hændelser` $d_{j}$|$n_{j}-d_{j}$|$\frac{n_{j}-d_{j}}{n_{j}}$|$\hat{S}(t_{j})$|
|---|:-----------------:|:-----------------:|:-----------:|:---|:--------------|
|0|77  |0 |0 |1                          |$\hat{S}(t_{j})=1$   |
|1|77  |4 |73|$1 \times \frac{73}{77}$   |$\hat{S}(t_{j})=0,95$|
|2|73  |10|63|$0,95 \times \frac{63}{73}$|$\hat{S}(t_{j})=0,82$|
|3|73  |63|14|$0,82 \times \frac{49}{63}$|$\hat{S}(t_{j})=0,64$|
|4|73  |49|8 |$0,64 \times \frac{41}{49}$|$\hat{S}(t_{j})=0,53$|
|5|73  |41|6 |$0,53 \times \frac{35}{41}$|$\hat{S}(t_{j})=0,45$|
|$t_{j}$|... |...|... |...|$\hat{S}(t_{j})=0$|

: Regneeksempel med de økonomistuderende i "flyttedataen"

<br/>

$$ 
\hat{S}(4) = \frac{73}{77} \times \frac{63}{73} \times \frac{49}{63} \times \frac{41}{49} = 0,53
$$

$\hat{S}(t)$ vil **altid** være stigende eller konstant. Aldrig faldende. 

## Kaplan-Meier (3)

Alternativt kan ***KM*** estimeres som: 

$$
\hat{S} (t_\left({i}\right)) = \hat{S} (t_\left({i-1}\right)) \times P \left ( T > t  | T \geq t  \right) 
$$

Hvilket udtrykker sandsynligheden for overlevelse indtil tidspunkt $t_\left({j-1}\right)$ gange den betingede sandsynlighed for overlevelse for til $t_\left({j}\right)$. For eksempel, ved $t=4$: 

$\hat{S} (t_\left({4-1}\right)) = \frac{73}{77} \times \frac{63}{73} \times \frac{49}{63}$ 

og

$P \left ( T > 4  | T \geq 4  \right) = \frac{35}{41}$

::: aside
Uanset hvordan det udregnes er det "smarte" ved ***KM*** at estimeringen kan håndtere højre-censurerede observationer. 

***KM*** kaldes også til tider *the product-limit estimation*. 

:::

# Kaplan-Meier: Stratificering 

## Kaplan-Meier (4)

***Et af de typiske formål med en KM estimation, er at sammeligne to overlevelseskurver.*** Vi gør dette ved at tilføje en covariate (uafhængig variabel) i stedet for `1` (intercept-only model). 


::: columns
<!--  ------------------------------------------->
::: {.column width="50%"}
### Kode

```{r}
#| echo: true

fit <- survfit(Surv(dur, status) ~ udd, data = df)

```
:::

::: {.column width="50%"}
### Output

```{r fig.height=8}
#| echo: false

strat_plot <- 
  ggsurvplot(fit, data = df, 
           title = "Overlevelseskurve ('flytte.csv' data fra Moodle)",
           palette = c("#da1f66", "#003fa3"),
           xlab = TeX("Tid ($t$)"),
           ylab = TeX("$\\hat{S}(t)$"),
           linetype = "solid",
           surv.median.line = c("hv") ,
           conf.int = TRUE,
           pval = FALSE,
           risk.table = FALSE)

strat_plot[["plot"]] +
  theme_minimal()
  
```
:::

:::

## Kaplan-Meier (4) 

```{r}
#| echo: true

fit <- survfit(Surv(dur, status) ~ udd, data = df)

fit
```


## Kaplan-Meier (5)

```{r}
#| echo: true

fit <- survfit(Surv(dur, status) ~ udd, data = df)

summary(fit)

```

## Hvorfor sammenligne?

- Har forskellige grupper forskellig overlevelse? 

- Første skridt i undersøgelsen af ***hvorfor*** (i et `kausalt henseende`). 

  - Dette kan dog ikke besvares med ***KM***, som vi vil vende tilbage til.

## Hvorfor sammenligne? (2)

Vi tester:

$$H_{0}: S_{1}(t)=S_{2}(t)=\dots=S_{n}(t)$$

Med andre ord: 

`Nul-hypotese`: de to overlevelsesfunktioner er **ens**. $H_{0}: S_{1}=S_{2}$

`Alternativ hypotese`: de to hypoteser er **forskellige**. $H_{1}: S_{1} \neq S_{2}$

Ved flere grupper er logikken den samme. **Alle** overlevelsesfunktioner **er ens** eller **mindst to** overlevelsesfunktioner **er forskellige**

## Hvordan sammenligner vi?

Der er forskellige signifikanstests, men `log-rank` (Mantel-Haenszel) test er den mest anvendte. 

```{r fig.width=7, fig.align="center"}
#| echo: false

df <- read_csv(here::here("flytte.csv"))

fit <- survfit(Surv(dur, status) ~ udd, data = df)

strat_plot <- 
  ggsurvplot(fit, data = df, 
           title = "Overlevelseskurve ('flytte.csv' data fra Moodle)",
           palette = c("#da1f66", "#003fa3"),
           xlab = TeX("Tid ($t$)"),
           ylab = TeX("$\\hat{S}(t)$"),
           linetype = "solid",
           surv.median.line = c("hv") ,
           conf.int = TRUE,
           pval = FALSE,
           risk.table = FALSE)

strat_plot[["plot"]] +
  theme_minimal()
  
```

## Hvordan sammenligner vi? (2)

- Teknisk er en log-rank test en "`large scale chi-squared test`", der estimerer en overordnet---global---sammenligning af to eller flere ***KM*** kurver. 

- Det gør vi ved at udvide de forrige tabeller---dem med *tid*, *hændelse*, *risksæt*, *censureringer*, osv.---til også at inkludere `forventede antal hændelser`. Forventede hændelser, $e$, for hver gruppe, er givet ved:

$$ 
e_{1} = \left ( \frac{n_{1}}{n_{1}+n_{2}} \right ) \times \left ( d_{1}+d_{2} \right )
$$
og 

$$ 
e_{2} = \left ( \frac{n_{1}}{n_{1}+n_{2}} \right ) \times \left ( d_{1}+d_{2} \right )
$$
Herfra kan vi udregne forskellen i observeret $O$ og forventet $E$, som: 

$$
O_{i}-E_{i}=\sum \left ( d_{i} - e_{i} \right )
$$

hvor $i\in1,2$. 

Summen for de to grupper vil være det samme, bortset fra den ene har minus foran summen. 

## Hvordan sammenligner vi? (3)

Log-rank statistikken for to grupper (1, 2) er slutteligt givet ved: 

$$
\frac{\left ( O_{1} - E_{1}\right )^{2} }{\text{Var} \left (  O_{1} - E_{1} \right ) }
$$
eller

$$
\frac{\left ( O_{2} - E_{2}\right )^{2} }{\text{Var} \left (  O_{2} - E_{2} \right ) }
$$

P-værdien udleder vi fra $\chi^{2}$ fordelingen på klassisk vis. **Dette lader vi selvfølgelig computeren gøre, og printes ofte i bunden eller toppen af outputtet, afhængigt af kode-sprog**. 

## Hvordan sammenligner vi? (4)

Alternative til `log-rank` er `Wilcoxon`, `Tarone-Ware`, `Peto`, og `Flemington-Harrington` tests.  

Disse er alle variationer af log-rank testen med har forskellige vægte, der hhv. vægter tidlige og sene hændelser i forløbet. God praksis er at vælge en test *a priori* baseret på forventninger om dataen og fænoment. Disse forventninger kan trykprøves ved også at lave de alternative tests. Ofte vil de andre test have samme signifikans-niveau. 

## Hvordan sammenligner vi? (4)


```{r}
#| echo: true

survdiff(Surv(dur, status) ~ udd, data = df)

```

<br/>

::: aside 

`survdiff()` bruger en approximeret formel: 

$$
\chi^{2} \approx \sum_{i}^{\# \: \text{antal grupper}} \frac{(O_{i}-E_{i})^{2} }{E_{i}}
$$

se Kleinbaun og Klein (2020, s. 71).

:::



# Overlevelsesdata og øvelse

## `single-episode file` med fixed/`time-invariant` variable: 

```{r}
#| echo: true
#| eval: false

load("First_child.rda")

```

## `single-episode file` med fixed/`time-invariant` variable: 

- `PNR` (individuel ID)
- `aar` (året for hændelsen)
- `ALDER` (alder på hændelsestidspunktet)
- `KOEN` (kønsvariabel – baseret på cpr)
- `f_udd` (højeste fuldførste uddannelse)
- `region18` (bopælsregion da personen er 18 år)
- `event` (1=hændelse, 0=uændret tilstand)



```{r}
#| echo: false
#| eval: false

load ("First_child.rda")

data <- 
  df %>% 
  select(pnr, aar, ALDER, KOEN, C_ANTBOERNF, f_udd, region) %>% 
  mutate(age = as.numeric(ALDER)) %>%
  filter(age >= 18) %>%                                               
  mutate(person_start = case_when(lag(pnr) == pnr ~ 0, TRUE ~ 1)) %>% 
  mutate(born = as.numeric(C_ANTBOERNF)) %>% 
  mutate(kvinde = if_else(KOEN == 2, 1, 0)) %>%
  select(- C_ANTBOERNF, - KOEN, -ALDER) %>% 
  mutate(event = if_else(lag(born) == 0 & born == 1, 1, 0)) %>% 
  mutate(born_aar = if_else(event == 1, aar, 0)) %>% 
  mutate(censor = if_else(event == 1 & aar < 2010 | aar == 2010 & event %in% c(1, 0), 1, 0)) %>% 
  filter(censor == 1,
         kvinde == 1,
         born %in% c(1, 0)) %>% 
  group_by(pnr) %>% 
  slice_min(age) %>% 
  ungroup() %>% 
  filter(aar >= 1988,
         age < 40) 

sum(data[["event"]], na.rm = TRUE)
mean(data[["age"]], na.rm = TRUE)

```

```{r}
#| echo: false
#| eval: false

test <- anti_join(First_child, data, by = "pnr")

sum(First_child[["event"]], na.rm = TRUE)
mean(First_child[["age"]], na.rm = TRUE)

```



## Øvelse

***I skal undersøge tiden indtil første fødte barn***. Dette eksempel fortsætter gennem forelæsningerne, således i kan bygge ovenpå hver øvelse. MEN, har i lyst til at arbejde med en anden problemstilling i finder interressant, eller evt.  matcher med jeres aktuelle projektarbejde, er i også velkomne til det. 

1. Diskuter hvorfor variablene er fixed/"tids-invariante"? Hvorfor ikke?

2. Konstruer en meningsfuld tids-variabel ud fra `ALDER`, således alle starter i 	populationen under risiko (`tid = 1`), når de fyldte 18 år.

3.1 Lav en `KM` estimation: beskriv og fortolk resultaterne.

3.2 Lav en meningsfuld og ***fyldestgørende*** visualisering. 

4. Test og visualiser om der er forskel mellem regioner (`region18`) i tiden indtil første fødte barn.

```{r}
df <- haven::read_sas("//Volumes//Fileshares//mikrooekonometri-F25//Råfiler//pnr_sample.sas7bdat")

```



```{r}
library(tidyverse)
library(survival)

load("//Volumes//Fileshares//mikrooekonometri-F25//Råfiler//First_child.rda")

First_child <- 
  First_child %>% 
  mutate(tid = age - 17) %>% 
  filter(kon != "Mand")

KM <- survfit(Surv(tid, event) ~ 1, data = First_child)

# Alternativ: 
alder <- First_child[["age"]]-17
alder <- First_child$age-17
event <- First_child[["event"]]

KM1 <- survfit(Surv(alder, event) ~ 1)

KM

```

```{r}
# install.packages("ggsurvfit")
library(ggsurvfit)
library(latex2exp)

ggsurvfit(KM) + 
  add_confidence_interval() + 
  add_risktable() +
  add_quantile(y_value = 0.5, 
               linetype = "dotted", 
               color = "grey30", 
               linewidth = 0.8) +
  labs(y = TeX("\\hat{S}(t)"), x = "tid (t)") + 
  theme_minimal()

```

```{r}
KM <- survfit(Surv(tid, event) ~ region18, data = First_child)

ggsurvfit(KM) + 
  add_confidence_interval() + 
  labs(y = TeX("\\hat{S}(t)"), x = "tid (t)") + 
  theme_minimal()
```

